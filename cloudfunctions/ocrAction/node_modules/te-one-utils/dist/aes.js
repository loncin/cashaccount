"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decrypt = void 0;
const crypto = require("crypto");
function checkSize(size) {
    if (size !== 128 && size !== 256) {
        throw ("AES.setKeySize error: " + size + "just support 128 or 256");
    }
    ;
}
;
function checkKey(key, size) {
    if (key.length !== (size / 8)) {
        throw ("AES.checkKey error: key length is not" + (size / 8) + ":" + key.length);
    }
}
function encrypt(text, k, mode, size, inEncode, outEncode, v) {
    let key = k || "8395810531049180";
    let s = size || 128;
    checkSize(s);
    checkKey(key, s);
    let inC = inEncode || "utf8";
    let outC = outEncode || "base64";
    let model = (mode && ["ecb", "ebc"].includes(mode.toLocaleLowerCase())) ? "ecb" : "cbc";
    let vi = v || (model == "ecb" ? Buffer.from([]) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
    let algorithm = "aes-" + s + "-" + model;
    let psw = crypto.createCipheriv(algorithm, key, vi);
    psw.setAutoPadding(true);
    let buff = Buffer.from(text, inC);
    let out = Buffer.concat([psw.update(buff), psw.final()]);
    return Buffer.from(out).toString(outC);
}
exports.default = encrypt;
;
exports.decrypt = (text, k, mode, size, inEncode, outEncode, v) => {
    let key = k || "8395810531049180";
    let s = size || 128;
    checkSize(s);
    checkKey(key, s);
    let inC = inEncode || "base64";
    let outC = outEncode || "utf8";
    let model = (mode && mode.toLocaleLowerCase() === "ecb") ? "ecb" : "cbc";
    let vi = v || (model == "ecb" ? Buffer.from([]) : Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));
    let algorithm = "aes-" + s + "-" + model;
    let psw = crypto.createDecipheriv(algorithm, key, vi);
    psw.setAutoPadding(true);
    let buff = Buffer.from(text, inC);
    let out = Buffer.concat([psw.update(buff), psw.final()]);
    return Buffer.from(out).toString(outC);
};
